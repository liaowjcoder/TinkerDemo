apply plugin: 'tinkerpatch-support'
// ${buildDir} 取AS中App下build的文件夹路径
def bakPath = file("${buildDir}/bakApk/")
// 1.0.0 基准apk所在的文件夹
def appName = "app_thinkerdemo"

tinkerpatchSupport {
    /** 可以在debug的时候关闭 tinkerPatch **/
    tinkerEnable = true
    //是否反射 Application 实现一键接入；一般来说，接入 Tinker 我们需要改造我们的 Application, 若这里为 true， 即我们无需对应用做任何改造即可接入。
    reflectApplication = true

    //将每次编译产生的 apk/mapping.txt/R.txt 归档存储的位置
    autoBackupApkPath = "${bakPath}"

    /** 在tinkerpatch.com得到的appKey **/
    appKey = "5561243f2b53515c"
    appVersion = "1.0"

    // 基准包的文件路径, 对应 tinker 插件中的 oldApk 参数;编译补丁包时，
    // 必需指定基准版本的 apk，默认值为空，则表示不是进行补丁包的编译。
    baseApkFile = "${bakPath}/${appName}/app-release.apk"
    // 基准包的 Proguard mapping.txt 文件路径, 对应 tinker 插件
    // applyMapping 参数；在编译新的 apk 时候，我们希望通过保持基准
    // apk 的 proguard 混淆方式，从而减少补丁包的大小。这是强烈推荐的，编译补丁包时，我们推荐输入基准 apk 生成的 mapping.txt 文件。
    baseProguardMappingFile = "${bakPath}/${appName}/app-release-mapping.txt"
    // 基准apk中资源文件
    baseResourceRFile = "${bakPath}/${appName}/app-release-R.txt"
}